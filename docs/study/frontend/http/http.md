# HTTP协议

- HyperText Transfer Protocol的缩写，也称为超文本传输协议，最初的版本只能用来传输html文件，现在则可以传输包括文字、图像、视频和二进制文件的所有内容。

> HTTP客户端（这里就是我们的浏览器）发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

- HTTP协议是无状态的，请求之间无关联。利用Cookie机制维护状态

## 网络七层模型

1. 应用层：网络服务与最终用户的一个接口。
   协议有：**HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP**
2. 表示层：数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
   格式有：**JPEG、ASCll、DECOIC、加密格式**等
3. 会话层：建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
   **对应主机进程，指本地主机与远程主机正在进行的会话**
4. 传输层：定义传输数据的协议端口号，以及流控和差错校验。
   协议有：**TCP UDP**，数据包一旦离开网卡即进入网络传输层
5. 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
   协议有：ICMP IGMP **IP（IPV4 IPV6） ARP** RARP
6. 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）
   **将比特组合成字节进而组合成帧**，用**MAC地址**访问介质，错误发现但不能纠正。
7. 物理层：建立、维护、断开物理连接。（由底层网络定义协议）

## TCP/IP协议

<span style='color:red'>不是</span>TCP和IP这两个协议的合称，而是指**因特网整个TCP/IP协议族**

从协议分层模型方面来讲，TCP/IP由四个层次组成：网络接口层、网络层、传输层、应用层。

- 网络接口层：负责接收IP数据包并通过网络发送，或者从网络上接收物理帧，抽出IP数据包，交给IP层
- 网络层：负责相邻计算机之间的通信
  - 处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口
  - 处理输入数据报：首先检查其合法性，然后进行寻径--假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报
  - 处理路径、流控、拥塞等问题
  - ARP是正向地址解析协议，通过已知的IP，寻找对应主机的MAC地址。
  - RARP是反向地址解析协议，通过MAC地址确定IP地址。
- 传输层：提供应用程序间的通信
  - 功能：一、格式化信息流；二、提供可靠传输。
  - 为实现提供可靠传输，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送，即<span style='color:red'>“三次握手”</span>过程，从而提供可靠的数据传输。
  - 传输层协议主要是：
    - 传输控制协议TCP（Transmission Control Protocol）
    - 用户数据报协议UDP（User Datagram protocol）
- 应用层：向用户提供一组常用的应用程序。
  - **FTP**（File Transfer Protocol）是文件传输协议，一般上传下载用FTP服务，数据端口是20，控制端口是21。
  - **Telnet**服务是用户远程登录服务，使用23端口，使用明码传送，保密性差、简单方便。
  - **DNS**（Domain Name Service）是域名解析服务，提供域名到IP地址之间的转换，使用端口53。
  - **SMTP**（Simple Mail Transfer Protocol）是简单邮件传输协议，用来控制信件的发送、中转，使用端口25。
  - **NFS**（Network File System）是网络文件系统，用于网络中不同主机间的文件共享。
  - **HTTP**（Hypertext Transfer Protocol）是超文本传输协议，用于实现互联网中的WWW服务，使用端口80



### 建立连接协议（三次握手）

> 3次握手是指发送了3个报文段

1. 第一次握手：客户端发送网络包，服务端收到了。

   服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

2. 第二次握手：服务端发包，客户端收到了。

   客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。

3. 第三次握手：客户端发包，服务端收到了。

   服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。

3次握手的目的：

1. 让通信双方都了解到一个连接正在建立，**让双方都得出自己、对方的接收、发送能力都正常的结论**
2. 利用数据包的选项来传输特殊的信息，交换初始序列号ISN



### 断开连接（四次挥手）

> 4次挥手是指发送了4个报文段

TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。

1. 当有一方要关闭连接时，会发送FIN指令告知对方，我要关闭连接了。

2. 对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以**继续传输数据**。

3. 对方等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。

4. 接收方发送ACK确认关闭连接。


注意，接收到FIN报文的一方只能回复一个ACK, 它是<span style='color:red'>无法马上返回对方一个FIN报文段</span>的，因为结束数据传输的“指令”是上层应用层给出的。





## http1.0 / http1.1 / https / spdy / http2.0



### http1.0与http1.1的区别

- 缓存：http1.1引入etag,if-none-match等机制控制缓存
- range头域：http1.1在请求头引入range字段，请求资源的某一部分，返回206
- 错误代码：新增24个错误代码如409，410
- host头处理：1.0认为服务器对应单ip，所以不传host。1.1请求和响应都支持host，以应对单ip对应多虚拟主机
- 长连接：http1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
  - HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中<span style='color:red'>不需要等待服务器对前一个请求的响应</span>；只不过，客户端还是要按照发送请求的顺序来接收响应。
  - Head of line blocking：线头阻塞。服务器是顺序处理请求的，如果前一个请求非常耗时，那么后续请求都会受到影响。
  - 大部分桌面浏览器仍然会选择默认关闭HTTP pipelining这一功能。

### http1.x的问题

- 传输数据时，每次都要新建连接，增加延迟，移动端更明显
- 传输内容都是明文的，不安全
- header过大且不怎么变化，增加传输成本
- keep-alive虽然能弥补多次创建连接的延迟，但是会给服务器带来性能压力。并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在<span style='color:red'>文件</span>被请求之后还保持了不必要的连接很长时间。

### https

为解决上述问题，https出现了。

对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加



### http与https的区别

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题

![httpshttp](https://whyceycs.github.io/articles/study/frontend/http/httpshttp.png)



### spdy

2012年google提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者优点于一体的传输协议，主要解决：

- **复用流**：SPDY允许在一个连接上无限制并发流。因为请求在一个通道上，TCP效率更高：更少的网络连接，发出更少更密集的数据包。

- **请求优先级**：多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。

- **HTTP报头压缩**：SPDY压缩请求和响应HTTP报头，从而减少传输的数据包数量和字节数。

- **服务器启动流**：

  - Server push：SPDY通过X-Associated-Content头试验了服务器推送数据给客户端的选项。这个头告诉客户端服务器将在客户端请求资源之前，推送资源给它。对于初始页面下载（例如用户初次访问这个网站），这样能大大提升用户体验。
  - Server hint：在服务器事先知道客户端需要的资源的情况下，服务器使用X-Subresources头<span style='color:red'>建议客户端请求</span>特殊的资源。但是，服务器仍然在发送内容前等待客户请求。通过窄带，这个选项能减少一个客户端发现它所需要的资源的数百毫秒，可能更适合于非初始页面加载。

>  SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。



### http2.0

HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点：

1. HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS（SSL之上）。
2. HTTP2.0 消息头的压缩算法采用 [HPACK](http://http2.github.io/http2-spec/compression.html)，而非 SPDY 采用的 [DEFLATE](http://zh.wikipedia.org/wiki/DEFLATE)

  

### http2.0新特性：

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

![multiplexing](https://whyceycs.github.io/articles/study/frontend/http/multiplexing.png)

- **header压缩，**如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如[YouTuBe](https://www.youtube.com/)，等网站。



## WebSocket

- websocket是一种网络通信协议，是 HTML5 开始提供的一种<span style='color:red'>在单个 TCP 连接上进行全双工通讯</span>的协议。

- WebSocket是不限于HTTP协议的，但是由于现存大量的HTTP基础设施，代理，过滤，身份认证等等，WebSocket<span style='color:red'>借用HTTP和HTTPS的端口</span>。
- 由于使用HTTP的端口，因此TCP连接建立后的握手消息是基于HTTP的，由服务器判断这是一个HTTP协议，还是WebSocket协议。 WebSocket连接除了建立和关闭时的握手，数据传输和HTTP没丁点关系了。

- WebSocket也有自己一套帧协议。

### websocket、long poll、ajax轮询

- ajax轮询：隔几秒就发送一次请求
- long poll：阻塞型，没消息就一直不返回。有消息返回后，再次建立连接
- websocket：主动推送给客户端

### websocket、spdy

SPDY和WebSocket的关系比较复杂。


- SPDY想在不影响HTTP语义的情况下，替换HTTP底层传输的协议来加快页面加载时间。
SPDY的解决办法就是设计了一个会话层协议--帧协议，解决多路复用，优先级等问题，然后在其上实现了HTTP的语义。

- 补充关系，二者侧重点不同。SPDY更侧重于给Web页面的加载提速，而WebSocket更强调为Web应用提供一种双向的通讯机制以及API。
- 竞争关系，二者解决的问题有交集，比如在服务器推送上SPDY和WebSocket都提供了方案。


